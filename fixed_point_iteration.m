function [root, iterations, all_x] = fixed_point_iteration(g, x0, tol, max_iter)
% FIXED_POINT_ITERATION Знаходження кореня рівняння методом простої ітерації
%
% Опис методу:
% Метод простої ітерації (метод послідовних наближень) базується на перетворенні
% вихідного рівняння f(x) = 0 до вигляду x = g(x), де g(x) - ітераційна функція.
% Метод полягає в побудові послідовності x_{n+1} = g(x_n), яка при правильному
% виборі функції g(x) збігається до кореня рівняння. Умовою збіжності є
% |g'(x)| < 1 в околі шуканого кореня.
%
% Вхідні параметри:
%   g        - ітераційна функція (x = g(x))
%   x0       - початкове наближення
%   tol      - допустима похибка
%   max_iter - максимальна кількість ітерацій
%
% Вихідні параметри:
%   root        - знайдений корінь
%   iterations  - кількість ітерацій
%   all_x       - усі наближення, отримані в процесі роботи методу

% Ініціалізація
iterations = 0;
all_x = x0;
x = x0;

% Основний цикл
while iterations < max_iter
    % Обчислення наступного наближення
    x_new = g(x);
    all_x = [all_x; x_new];
    
    % Перевірка точності
    if abs(x_new - x) < tol
        root = x_new;
        iterations = iterations + 1;
        return;
    end
    
    % Підготовка до наступної ітерації
    x = x_new;
    iterations = iterations + 1;
end

% Якщо досягнуто максимальної кількості ітерацій
warning('Досягнуто максимальної кількості ітерацій. Метод може розбігатися.');
root = x;
end

% Приклад використання:
% % Для рівняння x^3 - x - 2 = 0 можна записати x = (x^3 - 2)/1 або x = (x + 2)^(1/3)
% % Оберемо варіант, який забезпечує збіжність: g(x) = (x + 2)^(1/3)
% g = @(x) (x + 2)^(1/3);
% [root, iter, all_x] = fixed_point_iteration(g, 1.5, 1e-6, 100);
% disp(['Корінь: ', num2str(root)]);
% disp(['Кількість ітерацій: ', num2str(iter)]); 